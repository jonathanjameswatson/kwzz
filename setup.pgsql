create table quizzes (
  id bigint generated by default as identity primary key,
  title text not null constraint title_check check (char_length(title) <= 50 and char_length(title) > 0),
  questions jsonb not null default '[]'::jsonb ,
  creator_id uuid not null references auth.users,
  is_published boolean not null default false,
  inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  fts tsvector generated always as (to_tsvector('english', title)) stored
);

alter table quizzes add constraint questions_are_valid check (
  extensions.validate_json_schema(
    '{
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "question": {
            "type": "string",
            "maxLength": 200
          },
          "topics": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 30
            },
            "maxItems": 10,
            "uniqueItems": true
          },
          "answerType": {
            "type": "string",
            "enum": [
              "singleChoice",
              "multipleChoice",
              "text"
            ]
          },
          "answers": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "answer": {
                  "type": "string",
                  "maxLength": 50
                },
                "isCorrect": {
                  "type": "boolean"
                }
              },
              "required": [
                "answer",
                "isCorrect"
              ],
              "additionalProperties": false
            },
            "maxItems": 10
          },
          "shouldShuffle": {
            "type": "boolean"
          }
        },
        "required": [
          "question",
          "topics",
          "answerType",
          "answers",
          "shouldShuffle"
        ],
        "additionalProperties": false
      },
      "maxItems": 25
    }',
    questions
  )
);

set schema 'extensions';

create or replace function validate_questions_answers(questions jsonb) returns boolean as $$
  select bool_and(
    exists (
      select *
      from jsonb_array_elements(question->'answers') answer
      where (answer->>'isCorrect')::boolean
    )
  )
  from jsonb_array_elements(questions) question
  where question->>'answerType' <> 'text';
$$ language sql;

set schema 'public';

alter table quizzes add constraint published_questions_are_valid check (
  (not is_published) or extensions.validate_json_schema(
    '{
      "items": {
        "properties": {
          "question": {
            "minLength": 1
          },
          "answers": {
            "items": {
              "properties": {
                "answer": {
                  "minLength": 1
                }
              }
            },
            "minItems": 1
          }
        }
      },
      "minItems": 1
    }',
    questions
  ) and (
    extensions.validate_questions_answers(questions)
  )
);

create index quizzes_fts on quizzes using gin (fts);

alter table quizzes
  enable row level security;

create policy "Creators can do anything to their own unpublished quizzes."
on quizzes
for all
using (
  auth.uid() = creator_id and (not is_published)
) with check (
  auth.uid() = creator_id
);

create policy "Anyone can see published quizzes."
on quizzes
for select
using (
  is_published
);

create extension if not exists moddatetime schema extensions;

create trigger
  handle_updated_at before update
on quizzes
for each row execute
  procedure extensions.moddatetime(updated_at);
